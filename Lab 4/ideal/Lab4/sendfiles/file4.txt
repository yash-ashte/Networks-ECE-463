GNU 'make'
1 Overview of 'make'
2 An Introduction to Makefiles
3 Writing Makefiles
4 Writing Rules
5 Writing Recipes in Rules
6 How to Use Variables
7 Conditional Parts of Makefiles
8 Functions for Transforming Text
9 How to Run 'make'
10 Using Implicit Rules
11 Using 'make' to Update Archive Files
12 Extending GNU 'make'
13 Integrating GNU 'make'
14 Features of GNU 'make'
15 Incompatibilities and Missing Features
16 Makefile Conventions
Appendix A Quick Reference
Appendix B Errors Generated by Make
Appendix C Complex Makefile Example
Appendix D GNU Free Documentation License
Index of Concepts
Index of Functions, Variables, & Directives
GNU 'make'
1 Overview of 'make'
  1.1 How to Read This Manual
  1.2 Problems and Bugs
2 An Introduction to Makefiles
  2.1 What a Rule Looks Like
  2.2 A Simple Makefile
  2.3 How 'make' Processes a Makefile
  2.4 Variables Make Makefiles Simpler
  2.5 Letting 'make' Deduce the Recipes
  2.6 Another Style of Makefile
  2.7 Rules for Cleaning the Directory
3 Writing Makefiles
  3.1 What Makefiles Contain
    3.1.1 Splitting Long Lines
  3.2 What Name to Give Your Makefile
  3.3 Including Other Makefiles
  3.4 The Variable 'MAKEFILES'
  3.5 How Makefiles Are Remade
  3.6 Overriding Part of Another Makefile
  3.7 How 'make' Reads a Makefile
  3.8 How Makefiles Are Parsed
  3.9 Secondary Expansion
4 Writing Rules
  4.1 Rule Example
  4.2 Rule Syntax
  4.3 Types of Prerequisites
  4.4 Using Wildcard Characters in File Names
    4.4.1 Wildcard Examples
    4.4.2 Pitfalls of Using Wildcards
    4.4.3 The Function 'wildcard'
  4.5 Searching Directories for Prerequisites
    4.5.1 'VPATH': Search Path for All Prerequisites
    4.5.2 The 'vpath' Directive
    4.5.3 How Directory Searches are Performed
    4.5.4 Writing Recipes with Directory Search
    4.5.5 Directory Search and Implicit Rules
    4.5.6 Directory Search for Link Libraries
  4.6 Phony Targets
  4.7 Rules without Recipes or Prerequisites
  4.8 Empty Target Files to Record Events
  4.9 Special Built-in Target Names
  4.10 Multiple Targets in a Rule
  4.11 Multiple Rules for One Target
  4.12 Static Pattern Rules
    4.12.1 Syntax of Static Pattern Rules
    4.12.2 Static Pattern Rules versus Implicit Rules
  4.13 Double-Colon Rules
  4.14 Generating Prerequisites Automatically
5 Writing Recipes in Rules
  5.1 Recipe Syntax
    5.1.1 Splitting Recipe Lines
    5.1.2 Using Variables in Recipes
  5.2 Recipe Echoing
  5.3 Recipe Execution
    5.3.1 Using One Shell
    5.3.2 Choosing the Shell
  5.4 Parallel Execution
    5.4.1 Disabling Parallel Execution
    5.4.2 Output During Parallel Execution
    5.4.3 Input During Parallel Execution
  5.5 Errors in Recipes
  5.6 Interrupting or Killing 'make'
  5.7 Recursive Use of 'make'
    5.7.1 How the 'MAKE' Variable Works
    5.7.2 Communicating Variables to a Sub-'make'
    5.7.3 Communicating Options to a Sub-'make'
    5.7.4 The '--print-directory' Option
  5.8 Defining Canned Recipes
  5.9 Using Empty Recipes
6 How to Use Variables
  6.1 Basics of Variable References
  6.2 The Two Flavors of Variables
    6.2.1 Recursively Expanded Variable Assignment
    6.2.2 Simply Expanded Variable Assignment
    6.2.3 Immediately Expanded Variable Assignment
    6.2.4 Conditional Variable Assignment
  6.3 Advanced Features for Reference to Variables
    6.3.1 Substitution References
    6.3.2 Computed Variable Names
  6.4 How Variables Get Their Values
  6.5 Setting Variables
  6.6 Appending More Text to Variables
  6.7 The 'override' Directive
  6.8 Defining Multi-Line Variables
  6.9 Undefining Variables
  6.10 Variables from the Environment
  6.11 Target-specific Variable Values
  6.12 Pattern-specific Variable Values
  6.13 Suppressing Inheritance
  6.14 Other Special Variables
7 Conditional Parts of Makefiles
  7.1 Example of a Conditional
  7.2 Syntax of Conditionals
  7.3 Conditionals that Test Flags
8 Functions for Transforming Text
  8.1 Function Call Syntax
  8.2 Functions for String Substitution and Analysis
  8.3 Functions for File Names
  8.4 Functions for Conditionals
  8.5 The 'let' Function
  8.6 The 'foreach' Function
  8.7 The 'file' Function
  8.8 The 'call' Function
  8.9 The 'value' Function
  8.10 The 'eval' Function
  8.11 The 'origin' Function
  8.12 The 'flavor' Function
  8.13 Functions That Control Make
  8.14 The 'shell' Function
  8.15 The 'guile' Function
9 How to Run 'make'
  9.1 Arguments to Specify the Makefile
  9.2 Arguments to Specify the Goals
  9.3 Instead of Executing Recipes
  9.4 Avoiding Recompilation of Some Files
  9.5 Overriding Variables
  9.6 Testing the Compilation of a Program
  9.7 Temporary Files
  9.8 Summary of Options
10 Using Implicit Rules
  10.1 Using Implicit Rules
  10.2 Catalogue of Built-In Rules
  10.3 Variables Used by Implicit Rules
  10.4 Chains of Implicit Rules
  10.5 Defining and Redefining Pattern Rules
    10.5.1 Introduction to Pattern Rules
    10.5.2 Pattern Rule Examples
    10.5.3 Automatic Variables
    10.5.4 How Patterns Match
    10.5.5 Match-Anything Pattern Rules
    10.5.6 Canceling Implicit Rules
  10.6 Defining Last-Resort Default Rules
  10.7 Old-Fashioned Suffix Rules
  10.8 Implicit Rule Search Algorithm
11 Using 'make' to Update Archive Files
  11.1 Archive Members as Targets
  11.2 Implicit Rule for Archive Member Targets
    11.2.1 Updating Archive Symbol Directories
  11.3 Dangers When Using Archives
  11.4 Suffix Rules for Archive Files
12 Extending GNU 'make'
  12.1 GNU Guile Integration
    12.1.1 Conversion of Guile Types
    12.1.2 Interfaces from Guile to 'make'
    12.1.3 Example Using Guile in 'make'
  12.2 Loading Dynamic Objects
    12.2.1 The 'load' Directive
    12.2.2 How Loaded Objects Are Remade
    12.2.3 Loaded Object Interface
    12.2.4 Example Loaded Object
13 Integrating GNU 'make'
  13.1 Sharing Job Slots with GNU 'make'
    13.1.1 POSIX Jobserver Interaction
    13.1.2 Windows Jobserver Interaction
  13.2 Synchronized Terminal Output
14 Features of GNU 'make'
15 Incompatibilities and Missing Features
16 Makefile Conventions
  16.1 General Conventions for Makefiles
  16.2 Utilities in Makefiles
  16.3 Variables for Specifying Commands
  16.4 'DESTDIR': Support for Staged Installs
  16.5 Variables for Installation Directories
  16.6 Standard Targets for Users
  16.7 Install Command Categories
Appendix A Quick Reference
Appendix B Errors Generated by Make
Appendix C Complex Makefile Example
Appendix D GNU Free Documentation License
Index of Concepts
Index of Functions, Variables, & Directives
GNU 'make'
**********

This file documents the GNU 'make' utility, which determines
automatically which pieces of a large program need to be recompiled, and
issues the commands to recompile them.

   This is Edition 0.77, last updated 26 February 2023, of 'The GNU Make
Manual', for GNU 'make' version 4.4.1.

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021,
2022, 2023 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

1 Overview of 'make'
********************

The 'make' utility automatically determines which pieces of a large
program need to be recompiled, and issues commands to recompile them.
This manual describes GNU 'make', which was implemented by Richard
Stallman and Roland McGrath.  Development since Version 3.76 has been
handled by Paul D. Smith.

   GNU 'make' conforms to section 6.2 of 'IEEE Standard 1003.2-1992'
(POSIX.2).

   Our examples show C programs, since they are most common, but you can
use 'make' with any programming language whose compiler can be run with
a shell command.  Indeed, 'make' is not limited to programs.  You can
use it to describe any task where some files must be updated
automatically from others whenever the others change.

Preparing and Running Make
==========================

To prepare to use 'make', you must write a file called the "makefile"
that describes the relationships among files in your program and
provides commands for updating each file.  In a program, typically, the
executable file is updated from object files, which are in turn made by
compiling source files.

   Once a suitable makefile exists, each time you change some source
files, this simple shell command:

     make

suffices to perform all necessary recompilations.  The 'make' program
uses the makefile data base and the last-modification times of the files
to decide which of the files need to be updated.  For each of those
files, it issues the recipes recorded in the data base.

   You can provide command line arguments to 'make' to control which
files should be recompiled, or how.  *Note How to Run 'make': Running.

1.1 How to Read This Manual
===========================

If you are new to 'make', or are looking for a general introduction,
read the first few sections of each chapter, skipping the later
sections.  In each chapter, the first few sections contain introductory
or general information and the later sections contain specialized or
technical information.  The exception is the second chapter, *note An
Introduction to Makefiles: Introduction, all of which is introductory.

   If you are familiar with other 'make' programs, see *note Features of
GNU 'make': Features, which lists the enhancements GNU 'make' has, and
*note Incompatibilities and Missing Features: Missing, which explains
the few things GNU 'make' lacks that others have.

   For a quick summary, see *note Options Summary::, *note Quick
Reference::, and *note Special Targets::.

1.2 Problems and Bugs
=====================

If you have problems with GNU 'make' or think you've found a bug, please
report it to the developers; we cannot promise to do anything but we
might well want to fix it.

   Before reporting a bug, make sure you've actually found a real bug.
Carefully reread the documentation and see if it really says you can do
what you're trying to do.  If it's not clear whether you should be able
to do something or not, report that too; it's a bug in the
documentation!

   Before reporting a bug or trying to fix it yourself, try to isolate
it to the smallest possible makefile that reproduces the problem.  Then
send us the makefile and the exact results 'make' gave you, including
any error or warning messages.  Please don't paraphrase these messages:
it's best to cut and paste them into your report.  When generating this
small makefile, be sure to not use any non-free or unusual tools in your
recipes: you can almost always emulate what such a tool would do with
simple shell commands.  Finally, be sure to explain what you expected to
occur; this will help us decide whether the problem was really in the
documentation.

   Once you have a precise problem you can report it in one of two ways.
Either send electronic mail to:

         bug-make@gnu.org

or use our Web-based project management tool, at:

         https://savannah.gnu.org/projects/make/

In addition to the information above, please be careful to include the
version number of 'make' you are using.  You can get this information
with the command 'make --version'.  Be sure also to include the type of
machine and operating system you are using.  One way to obtain this
information is by looking at the final lines of output from the command
'make --help'.

   If you have a code change you'd like to submit, see the 'README' file
section "Submitting Patches" for information.

2 An Introduction to Makefiles
******************************

You need a file called a "makefile" to tell 'make' what to do.  Most
often, the makefile tells 'make' how to compile and link a program.

   In this chapter, we will discuss a simple makefile that describes how
to compile and link a text editor which consists of eight C source files
and three header files.  The makefile can also tell 'make' how to run
miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).  To see a more complex example
of a makefile, see *note Complex Makefile::.

   When 'make' recompiles the editor, each changed C source file must be
recompiled.  If a header file has changed, each C source file that
includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.

2.1 What a Rule Looks Like
==========================

A simple makefile consists of "rules" with the following shape:

     TARGET ... : PREREQUISITES ...
             RECIPE
             ...
             ...

   A "target" is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the name of an action to carry out, such as 'clean' (*note
Phony Targets::).

   A "prerequisite" is a file that is used as input to create the
target.  A target often depends on several files.

   A "recipe" is an action that 'make' carries out.  A recipe may have
more than one command, either on the same line or each on its own line.
*Please note:* you need to put a tab character at the beginning of every
recipe line!  This is an obscurity that catches the unwary.  If you
prefer to prefix your recipes with a character other than tab, you can
set the '.RECIPEPREFIX' variable to an alternate character (*note
Special Variables::).

   Usually a recipe is in a rule with prerequisites and serves to create
a target file if any of the prerequisites change.  However, the rule
that specifies a recipe for the target need not have prerequisites.  For
example, the rule containing the delete command associated with the
target 'clean' does not have prerequisites.

   A "rule", then, explains how and when to remake certain files which
are the targets of the particular rule.  'make' carries out the recipe
on the prerequisites to create or update the target.  A rule can also
explain how and when to carry out an action.  *Note Writing Rules:
Rules.

   A makefile may contain other text besides rules, but a simple
makefile need only contain rules.  Rules may look somewhat more
complicated than shown in this template, but all fit the pattern more or
less.

2.2 A Simple Makefile
=====================

Here is a straightforward makefile that describes the way an executable
file called 'edit' depends on eight object files which, in turn, depend
on eight C source and three header files.

   In this example, all the C files include 'defs.h', but only those
defining editing commands include 'command.h', and only low level files
that change the editor buffer include 'buffer.h'.

     edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

We split each long line into two lines using backslash/newline; this is
like using one long line, but is easier to read.  *Note Splitting Long
Lines: Splitting Lines.

   To use this makefile to create the executable file called 'edit',
type:

     make

   To use this makefile to delete the executable file and all the object
files from the directory, type:

     make clean

   In the example makefile, the targets include the executable file
'edit', and the object files 'main.o' and 'kbd.o'.  The prerequisites
are files such as 'main.c' and 'defs.h'.  In fact, each '.o' file is
both a target and a prerequisite.  Recipes include 'cc -c main.c' and
'cc -c kbd.c'.

   When a target is a file, it needs to be recompiled or relinked if any
of its prerequisites change.  In addition, any prerequisites that are
themselves automatically generated should be updated first.  In this
example, 'edit' depends on each of the eight object files; the object
file 'main.o' depends on the source file 'main.c' and on the header file
'defs.h'.

   A recipe may follow each line that contains a target and
prerequisites.  These recipes say how to update the target file.  A tab
character (or whatever character is specified by the '.RECIPEPREFIX'
variable; *note Special Variables::) must come at the beginning of every
line in the recipe to distinguish recipes from other lines in the
makefile.  (Bear in mind that 'make' does not know anything about how
the recipes work.  It is up to you to supply recipes that will update
the target file properly.  All 'make' does is execute the recipe you
have specified when the target file needs to be updated.)

   The target 'clean' is not a file, but merely the name of an action.
Since you normally do not want to carry out the actions in this rule,
'clean' is not a prerequisite of any other rule.  Consequently, 'make'
never does anything with it unless you tell it specifically.  Note that
this rule not only is not a prerequisite, it also does not have any
prerequisites, so the only purpose of the rule is to run the specified
recipe.  Targets that do not refer to files but are just actions are
called "phony targets".  *Note Phony Targets::, for information about
this kind of target.  *Note Errors in Recipes: Errors, to see how to
cause 'make' to ignore errors from 'rm' or any other command.

2.3 How 'make' Processes a Makefile
===================================

By default, 'make' starts with the first target (not targets whose names
start with '.' unless they also contain one or more '/').  This is
called the "default goal".  ("Goals" are the targets that 'make' strives
ultimately to update.  You can override this behavior using the command
line (*note Arguments to Specify the Goals: Goals.) or with the
'.DEFAULT_GOAL' special variable (*note Other Special Variables: Special
Variables.).

   In the simple example of the previous section, the default goal is to
update the executable program 'edit'; therefore, we put that rule first.

   Thus, when you give the command:

     make

'make' reads the makefile in the current directory and begins by
processing the first rule.  In the example, this rule is for relinking
'edit'; but before 'make' can fully process this rule, it must process
the rules for the files that 'edit' depends on, which in this case are
the object files.  Each of these files is processed according to its own
rule.  These rules say to update each '.o' file by compiling its source
file.  The recompilation must be done if the source file, or any of the
header files named as prerequisites, is more recent than the object
file, or if the object file does not exist.

   The other rules are processed because their targets appear as
prerequisites of the goal.  If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell 'make' to do so (with a command such as 'make clean').

   Before recompiling an object file, 'make' considers updating its
prerequisites, the source file and header files.  This makefile does not
specify anything to be done for them--the '.c' and '.h' files are not
the targets of any rules--so 'make' does nothing for these files.  But
'make' would update automatically generated C programs, such as those
made by Bison or Yacc, by their own rules at this time.

   After recompiling whichever object files need it, 'make' decides
whether to relink 'edit'.  This must be done if the file 'edit' does not
exist, or if any of the object files are newer than it.  If an object
file was just recompiled, it is now newer than 'edit', so 'edit' is
relinked.

   Thus, if we change the file 'insert.c' and run 'make', 'make' will
compile that file to update 'insert.o', and then link 'edit'.  If we
change the file 'command.h' and run 'make', 'make' will recompile the
object files 'kbd.o', 'command.o' and 'files.o' and then link the file
'edit'.

2.4 Variables Make Makefiles Simpler
====================================

In our example, we had to list all the object files twice in the rule
for 'edit' (repeated here):

     edit : main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

   Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can
eliminate the risk and simplify the makefile by using a variable.
"Variables" allow a text string to be defined once and substituted in
multiple places later (*note How to Use Variables: Using Variables.).

   It is standard practice for every makefile to have a variable named
'objects', 'OBJECTS', 'objs', 'OBJS', 'obj', or 'OBJ' which is a list of
all object file names.  We would define such a variable 'objects' with a
line like this in the makefile:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we can
substitute the variable's value by writing '$(objects)' (*note How to
Use Variables: Using Variables.).

   Here is how the complete simple makefile looks when you use a
variable for the object files:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit $(objects)

2.5 Letting 'make' Deduce the Recipes
=====================================

It is not necessary to spell out the recipes for compiling the
individual C source files, because 'make' can figure them out: it has an
"implicit rule" for updating a '.o' file from a correspondingly named
'.c' file using a 'cc -c' command.  For example, it will use the recipe
'cc -c main.c -o main.o' to compile 'main.c' into 'main.o'.  We can
therefore omit the recipes from the rules for the object files.  *Note
Using Implicit Rules: Implicit Rules.

   When a '.c' file is used automatically in this way, it is also
automatically added to the list of prerequisites.  We can therefore omit
the '.c' files from the prerequisites, provided we omit the recipe.

   Here is the entire example, with both of these changes, and a
variable 'objects' as suggested above:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     main.o : defs.h
     kbd.o : defs.h command.h
     command.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.h

     .PHONY : clean
     clean :
             rm edit $(objects)

This is how we would write the makefile in actual practice.  (The
complications associated with 'clean' are described elsewhere.  See
*note Phony Targets::, and *note Errors in Recipes: Errors.)

   Because implicit rules are so convenient, they are important.  You
will see them used frequently.

2.6 Another Style of Makefile
=============================

When the objects of a makefile are created only by implicit rules, an
alternative style of makefile is possible.  In this style of makefile,
you group entries by their prerequisites instead of by their targets.
Here is what one looks like:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     $(objects) : defs.h
     kbd.o command.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

Here 'defs.h' is given as a prerequisite of all the object files;
'command.h' and 'buffer.h' are prerequisites of the specific object
files listed for them.

   Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one place.

2.7 Rules for Cleaning the Directory
====================================

Compiling a program is not the only thing you might want to write rules
for.  Makefiles commonly tell how to do a few other things besides
compiling a program: for example, how to delete all the object files and
executables so that the directory is 'clean'.

   Here is how we could write a 'make' rule for cleaning our example
editor:

     clean:
             rm edit $(objects)

   In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations.  We would do
this:

     .PHONY : clean
     clean :
             -rm edit $(objects)

This prevents 'make' from getting confused by an actual file called
'clean' and causes it to continue in spite of errors from 'rm'.  (See
*note Phony Targets::, and *note Errors in Recipes: Errors.)

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefile, we want the rule for 'edit', which recompiles the
editor, to remain the default goal.

   Since 'clean' is not a prerequisite of 'edit', this rule will not run
at all if we give the command 'make' with no arguments.  In order to
make the rule run, we have to type 'make clean'.  *Note How to Run
'make': Running.

3 Writing Makefiles
*******************

The information that tells 'make' how to recompile a system comes from
reading a data base called the "makefile".

3.1 What Makefiles Contain
==========================

Makefiles contain five kinds of things: "explicit rules", "implicit
rules", "variable definitions", "directives", and "comments".  Rules,
variables, and directives are described at length in later chapters.

   * An "explicit rule" says when and how to remake one or more files,
     called the rule's "targets".  It lists the other files that the
     targets depend on, called the "prerequisites" of the target, and
     may also give a recipe to use to create or update the targets.
     *Note Writing Rules: Rules.

   * An "implicit rule" says when and how to remake a class of files
     based on their names.  It describes how a target may depend on a
     file with a name similar to the target and gives a recipe to create
     or update such a target.  *Note Using Implicit Rules: Implicit
     Rules.

   * A "variable definition" is a line that specifies a text string
     value for a variable that can be substituted into the text later.
     The simple makefile example shows a variable definition for
     'objects' as a list of all object files (*note Variables Make
     Makefiles Simpler: Variables Simplify.).

   * A "directive" is an instruction for 'make' to do something special
     while reading the makefile.  These include:

        * Reading another makefile (*note Including Other Makefiles:
          Include.).

        * Deciding (based on the values of variables) whether to use or
          ignore a part of the makefile (*note Conditional Parts of
          Makefiles: Conditionals.).

        * Defining a variable from a verbatim string containing multiple
          lines (*note Defining Multi-Line Variables: Multi-Line.).

   * '#' in a line of a makefile starts a "comment".  It and the rest of
     the line are ignored, except that a trailing backslash not escaped
     by another backslash will continue the comment across multiple
     lines.  A line containing just a comment (with perhaps spaces
     before it) is effectively blank, and is ignored.  If you want a
     literal '#', escape it with a backslash (e.g., '\#').  Comments may
     appear on any line in the makefile, although they are treated
     specially in certain situations.

     You cannot use comments within variable references or function
     calls: any instance of '#' will be treated literally (rather than
     as the start of a comment) inside a variable reference or function
     call.

     Comments within a recipe are passed to the shell, just as with any
     other recipe text.  The shell decides how to interpret it: whether
     or not this is a comment is up to the shell.

     Within a 'define' directive, comments are not ignored during the
     definition of the variable, but rather kept intact in the value of
     the variable.  When the variable is expanded they will either be
     treated as 'make' comments or as recipe text, depending on the
     context in which the variable is evaluated.

3.1.1 Splitting Long Lines
--------------------------

Makefiles use a "line-based" syntax in which the newline character is
special and marks the end of a statement.  GNU 'make' has no limit on
the length of a statement line, up to the amount of memory in your
computer.

   However, it is difficult to read lines which are too long to display
without wrapping or scrolling.  So, you can format your makefiles for
readability by adding newlines into the middle of a statement: you do
this by escaping the internal newlines with a backslash ('\') character.
Where we need to make a distinction we will refer to "physical lines" as
a single line ending with a newline (regardless of whether it is
escaped) and a "logical line" being a complete statement including all
escaped newlines up to the first non-escaped newline.

   The way in which backslash/newline combinations are handled depends
on whether the statement is a recipe line or a non-recipe line.
Handling of backslash/newline in a recipe line is discussed later (*note
Splitting Recipe Lines::).

   Outside of recipe lines, backslash/newlines are converted into a
single space character.  Once that is done, all whitespace around the
backslash/newline is condensed into a single space: this includes all
whitespace preceding the backslash, all whitespace at the beginning of
the line after the backslash/newline, and any consecutive
backslash/newline combinations.

   If the '.POSIX' special target is defined then backslash/newline
handling is modified slightly to conform to POSIX.2: first, whitespace
preceding a backslash is not removed and second, consecutive
backslash/newlines are not condensed.

Splitting Without Adding Whitespace
...................................

If you need to split a line but do _not_ want any whitespace added, you
can utilize a subtle trick: replace your backslash/newline pairs with
the three characters dollar sign, backslash, and newline:

     var := one$\
            word

   After 'make' removes the backslash/newline and condenses the
following line into a single space, this is equivalent to:

     var := one$ word

   Then 'make' will perform variable expansion.  The variable reference
'$ ' refers to a variable with the one-character name " " (space) which
does not exist, and so expands to the empty string, giving a final
assignment which is the equivalent of:

     var := oneword

3.2 What Name to Give Your Makefile
===================================

By default, when 'make' looks for the makefile, it tries the following
names, in order: 'GNUmakefile', 'makefile' and 'Makefile'.

   Normally you should call your makefile either 'makefile' or
'Makefile'.  (We recommend 'Makefile' because it appears prominently
near the beginning of a directory listing, right near other important
files such as 'README'.)  The first name checked, 'GNUmakefile', is not
recommended for most makefiles.  You should use this name if you have a
makefile that is specific to GNU 'make', and will not be understood by
other versions of 'make'.  Other 'make' programs look for 'makefile' and
'Makefile', but not 'GNUmakefile'.

   If 'make' finds none of these names, it does not use any makefile.
Then you must specify a goal with a command argument, and 'make' will
attempt to figure out how to remake it using only its built-in implicit
rules.  *Note Using Implicit Rules: Implicit Rules.

   If you want to use a nonstandard name for your makefile, you can
specify the makefile name with the '-f' or '--file' option.  The
arguments '-f NAME' or '--file=NAME' tell 'make' to read the file NAME
as the makefile.  If you use more than one '-f' or '--file' option, you
can specify several makefiles.  All the makefiles are effectively
concatenated in the order specified.  The default makefile names
'GNUmakefile', 'makefile' and 'Makefile' are not checked automatically
if you specify '-f' or '--file'.

3.3 Including Other Makefiles
=============================

The 'include' directive tells 'make' to suspend reading the current
makefile and read one or more other makefiles before continuing.  The
directive is a line in the makefile that looks like this:

     include FILENAMES...

FILENAMES can contain shell file name patterns.  If FILENAMES is empty,
nothing is included and no error is printed.

   Extra spaces are allowed and ignored at the beginning of the line,
but the first character must not be a tab (or the value of
'.RECIPEPREFIX')--if the line begins with a tab, it will be considered a
recipe line.  Whitespace is required between 'include' and the file
names, and between file names; extra whitespace is ignored there and at
the end of the directive.  A comment starting with '#' is allowed at the
end of the line.  If the file names contain any variable or function
references, they are expanded.  *Note How to Use Variables: Using
Variables.

   For example, if you have three '.mk' files, 'a.mk', 'b.mk', and
'c.mk', and '$(bar)' expands to 'bish bash', then the following
expression

     include foo *.mk $(bar)

   is equivalent to

     include foo a.mk b.mk c.mk bish bash

   When 'make' processes an 'include' directive, it suspends reading of
the containing makefile and reads from each listed file in turn.  When
that is finished, 'make' resumes reading the makefile in which the
directive appears.

   One occasion for using 'include' directives is when several programs,
handled by individual makefiles in various directories, need to use a
common set of variable definitions (*note Setting Variables: Setting.)
or pattern rules (*note Defining and Redefining Pattern Rules: Pattern
Rules.).

   Another such occasion is when you want to generate prerequisites from
source files automatically; the prerequisites can be put in a file that
is included by the main makefile.  This practice is generally cleaner
than that of somehow appending the prerequisites to the end of the main
makefile as has been traditionally done with other versions of 'make'.
*Note Automatic Prerequisites::.

   If the specified name does not start with a slash (or a drive letter
and colon when GNU Make is compiled with MS-DOS / MS-Windows path
support), and the file is not found in the current directory, several
other directories are searched.  First, any directories you have
specified with the '-I' or '--include-dir' options are searched (*note
Summary of Options: Options Summary.).  Then the following directories
(if they exist) are searched, in this order: 'PREFIX/include' (normally
'/usr/local/include' (1)) '/usr/gnu/include', '/usr/local/include',
'/usr/include'.

   The '.INCLUDE_DIRS' variable will contain the current list of
directories that make will search for included files.  *Note Other
Special Variables: Special Variables.

   You can avoid searching in these default directories by adding the
command line option '-I' with the special value '-' (e.g., '-I-') to the
command line.  This will cause 'make' to forget any already-set include
directories, including the default directories.

   If an included makefile cannot be found in any of these directories
it is not an immediately fatal error; processing of the makefile
containing the 'include' continues.  Once it has finished reading
makefiles, 'make' will try to remake any that are out of date or don't
exist.  *Note How Makefiles Are Remade: Remaking Makefiles.  Only after
it has failed to find a rule to remake the makefile, or it found a rule
but the recipe failed, will 'make' diagnose the missing makefile as a
fatal error.

   If you want 'make' to simply ignore a makefile which does not exist
or cannot be remade, with no error message, use the '-include' directive
instead of 'include', like this:

     -include FILENAMES...

   This acts like 'include' in every way except that there is no error
(not even a warning) if any of the FILENAMES (or any prerequisites of
any of the FILENAMES) do not exist or cannot be remade.

   For compatibility with some other 'make' implementations, 'sinclude'
is another name for '-include'.

   ---------- Footnotes ----------

   (1) GNU Make compiled for MS-DOS and MS-Windows behaves as if PREFIX
has been defined to be the root of the DJGPP tree hierarchy.

3.4 The Variable 'MAKEFILES'
============================

If the environment variable 'MAKEFILES' is defined, 'make' considers its
value as a list of names (separated by whitespace) of additional
makefiles to be read before the others.  This works much like the
'include' directive: various directories are searched for those files
(*note Including Other Makefiles: Include.).  In addition, the default
goal is never taken from one of these makefiles (or any makefile
included by them) and it is not an error if the files listed in
'MAKEFILES' are not found.

   The main use of 'MAKEFILES' is in communication between recursive
invocations of 'make' (*note Recursive Use of 'make': Recursion.).  It
usually is not desirable to set the environment variable before a
top-level invocation of 'make', because it is usually better not to mess
with a makefile from outside.  However, if you are running 'make'
without a specific makefile, a makefile in 'MAKEFILES' can do useful
things to help the built-in implicit rules work better, such as defining
search paths (*note Directory Search::).

   Some users are tempted to set 'MAKEFILES' in the environment
automatically on login, and program makefiles to expect this to be done.
This is a very bad idea, because such makefiles will fail to work if run
by anyone else.  It is much better to write explicit 'include'
directives in the makefiles.  *Note Including Other Makefiles: Include.

3.5 How Makefiles Are Remade
============================

Sometimes makefiles can be remade from other files, such as RCS or SCCS
files.  If a makefile can be remade from other files, you probably want
'make' to get an up-to-date version of the makefile to read in.

   To this end, after reading in all makefiles 'make' will consider each
as a goal target, in the order in which they were processed, and attempt
to update it.  If parallel builds (*note Parallel Execution: Parallel.)
are enabled then makefiles will be rebuilt in parallel as well.

   If a makefile has a rule which says how to update it (found either in
that very makefile or in another one) or if an implicit rule applies to
it (*note Using Implicit Rules: Implicit Rules.), it will be updated if
necessary.  After all makefiles have been checked, if any have actually
been changed, 'make' starts with a clean slate and reads all the
makefiles over again.  (It will also attempt to update each of them over
again, but normally this will not change them again, since they are
already up to date.)  Each restart will cause the special variable
'MAKE_RESTARTS' to be updated (*note Special Variables::).

   If you know that one or more of your makefiles cannot be remade and
you want to keep 'make' from performing an implicit rule search on them,
perhaps for efficiency reasons, you can use any normal method of
preventing implicit rule look-up to do so.  For example, you can write
an explicit rule with the makefile as the target, and an empty recipe
(*note Using Empty Recipes: Empty Recipes.).

   If the makefiles specify a double-colon rule to remake a file with a
recipe but no prerequisites, that file will always be remade (*note
Double-Colon::).  In the case of makefiles, a makefile that has a
double-colon rule with a recipe but no prerequisites will be remade
every time 'make' is run, and then again after 'make' starts over and
reads the makefiles in again.  This would cause an infinite loop: 'make'
would constantly remake the makefile and restart, and never do anything
else.  So, to avoid this, 'make' will *not* attempt to remake makefiles
which are specified as targets of a double-colon rule with a recipe but
no prerequisites.

   Phony targets (*note Phony Targets::) have the same effect: they are
never considered up-to-date and so an included file marked as phony
would cause 'make' to restart continuously.  To avoid this 'make' will
not attempt to remake makefiles which are marked phony.

   You can take advantage of this to optimize startup time: if you know
you don't need your 'Makefile' to be remade you can prevent make from
trying to remake it by adding either:

     .PHONY: Makefile

   or:

     Makefile:: ;

   If you do not specify any makefiles to be read with '-f' or '--file'
options, 'make' will try the default makefile names; *note What Name to
Give Your Makefile: Makefile Names.  Unlike makefiles explicitly
requested with '-f' or '--file' options, 'make' is not certain that
these makefiles should exist.  However, if a default makefile does not
exist but can be created by running 'make' rules, you probably want the
rules to be run so that the makefile can be used.

   Therefore, if none of the default makefiles exists, 'make' will try
to make each of them until it succeeds in making one, or it runs out of
names to try.  Note that it is not an error if 'make' cannot find or
make any makefile; a makefile is not always necessary.

   When you use the '-t' or '--touch' option (*note Instead of Executing
Recipes: Instead of Execution.), you would not want to use an
out-of-date makefile to decide which targets to touch.  So the '-t'
option has no effect on updating makefiles; they are really updated even
if '-t' is specified.  Likewise, '-q' (or '--question') and '-n' (or
'--just-print') do not prevent updating of makefiles, because an
out-of-date makefile would result in the wrong output for other targets.
Thus, 'make -f mfile -n foo' will update 'mfile', read it in, and then
print the recipe to update 'foo' and its prerequisites without running
it.  The recipe printed for 'foo' will be the one specified in the
updated contents of 'mfile'.

   However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by specifying the makefiles as
goals in the command line as well as specifying them as makefiles.  When
the makefile name is specified explicitly as a goal, the options '-t'
and so on do apply to them.

   Thus, 'make -f mfile -n mfile foo' would read the makefile 'mfile',
print the recipe needed to update it without actually running it, and
then print the recipe needed to update 'foo' without running that.  The
recipe for 'foo' will be the one specified by the existing contents of
'mfile'.

3.6 Overriding Part of Another Makefile
=======================================

Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the 'include' directive to include
one in the other, and add more targets or variable definitions.
However, it is invalid for two makefiles to give different recipes for
the same target.  But there is another way.

   In the containing makefile (the one that wants to include the other),
you can use a match-anything pattern rule to say that to remake any
target that cannot be made from the information in the containing
makefile, 'make' should look in another makefile.  *Note Pattern
Rules::, for more information on pattern rules.

   For example, if you have a makefile called 'Makefile' that says how
to make the target 'foo' (and other targets), you can write a makefile
called 'GNUmakefile' that contains:

     foo:
             frobnicate > foo

     %: force
             @$(MAKE) -f Makefile $@
     force: ;

   If you say 'make foo', 'make' will find 'GNUmakefile', read it, and
see that to make 'foo', it needs to run the recipe 'frobnicate > foo'.
If you say 'make bar', 'make' will find no way to make 'bar' in
'GNUmakefile', so it will use the recipe from the pattern rule: 'make -f
Makefile bar'.  If 'Makefile' provides a rule for updating 'bar', 'make'
will apply the rule.  And likewise for any other target that
'GNUmakefile' does not say how to make.

   The way this works is that the pattern rule has a pattern of just
'%', so it matches any target whatever.  The rule specifies a
prerequisite 'force', to guarantee that the recipe will be run even if
the target file already exists.  We give the 'force' target an empty
recipe to prevent 'make' from searching for an implicit rule to build
it--otherwise it would apply the same match-anything rule to 'force'
itself and create a prerequisite loop!

3.7 How 'make' Reads a Makefile
===============================

GNU 'make' does its work in two distinct phases.  During the first phase
it reads all the makefiles, included makefiles, etc.  and internalizes
all the variables and their values and implicit and explicit rules, and
builds a dependency graph of all the targets and their prerequisites.
During the second phase, 'make' uses this internalized data to determine
which targets need to be updated and run the recipes necessary to update
them.

   It's important to understand this two-phase approach because it has a
direct impact on how variable and function expansion happens; this is
often a source of some confusion when writing makefiles.  Below is a
summary of the different constructs that can be found in a makefile, and
the phase in which expansion happens for each part of the construct.

   We say that expansion is "immediate" if it happens during the first
phase: 'make' will expand that part of the construct as the makefile is
parsed.  We say that expansion is "deferred" if it is not immediate.
Expansion of a deferred construct part is delayed until the expansion is
used: either when it is referenced in an immediate context, or when it
is needed during the second phase.

   You may not be familiar with some of these constructs yet.  You can
reference this section as you become familiar with them, in later
chapters.

Variable Assignment
-------------------

Variable definitions are parsed as follows:

     IMMEDIATE = DEFERRED
     IMMEDIATE ?= DEFERRED
     IMMEDIATE := IMMEDIATE
     IMMEDIATE ::= IMMEDIATE
     IMMEDIATE :::= IMMEDIATE-WITH-ESCAPE
     IMMEDIATE += DEFERRED or IMMEDIATE
     IMMEDIATE != IMMEDIATE

     define IMMEDIATE
       DEFERRED
     endef

     define IMMEDIATE =
       DEFERRED
     endef

     define IMMEDIATE ?=
       DEFERRED
     endef

     define IMMEDIATE :=
       IMMEDIATE
     endef

     define IMMEDIATE ::=
       IMMEDIATE
     endef

     define IMMEDIATE :::=
       IMMEDIATE-WITH-ESCAPE
     endef

     define IMMEDIATE +=
       DEFERRED or IMMEDIATE
     endef

     define IMMEDIATE !=
       IMMEDIATE
     endef

   For the append operator '+=', the right-hand side is considered
immediate if the variable was previously set as a simple variable (':='
or '::='), and deferred otherwise.

   For the IMMEDIATE-WITH-ESCAPE operator ':::=', the value on the
right-hand side is immediately expanded but then escaped (that is, all
instances of '$' in the result of the expansion are replaced with '$$').

   For the shell assignment operator '!=', the right-hand side is
evaluated immediately and handed to the shell.  The result is stored in
the variable named on the left, and that variable is considered a
recursively expanded variable (and will thus be re-evaluated on each
reference).

Conditional Directives
----------------------

Conditional directives are parsed immediately.  This means, for example,
that automatic variables cannot be used in conditional directives, as
automatic variables are not set until the recipe for that rule is
invoked.  If you need to use automatic variables in a conditional
directive you _must_ move the condition into the recipe and use shell
conditional syntax instead.

Rule Definition
---------------

A rule is always expanded the same way, regardless of the form:

     IMMEDIATE : IMMEDIATE ; DEFERRED
             DEFERRED

   That is, the target and prerequisite sections are expanded
immediately, and the recipe used to build the target is always deferred.
This is true for explicit rules, pattern rules, suffix rules, static
pattern rules, and simple prerequisite definitions.

3.8 How Makefiles Are Parsed
============================

GNU 'make' parses makefiles line-by-line.  Parsing proceeds using the
following steps:

  1. Read in a full logical line, including backslash-escaped lines
     (*note Splitting Long Lines: Splitting Lines.).

  2. Remove comments (*note What Makefiles Contain: Makefile Contents.).

  3. If the line begins with the recipe prefix character and we are in a
     rule context, add the line to the current recipe and read the next
     line (*note Recipe Syntax::).

  4. Expand elements of the line which appear in an _immediate_
     expansion context (*note How 'make' Reads a Makefile: Reading
     Makefiles.).

  5. Scan the line for a separator character, such as ':' or '=', to
     determine whether the line is a macro assignment or a rule (*note
     Recipe Syntax::).

  6. Internalize the resulting operation and read the next line.

   An important consequence of this is that a macro can expand to an
entire rule, _if it is one line long_.  This will work:

     myrule = target : ; echo built

     $(myrule)

   However, this will not work because 'make' does not re-split lines
after it has expanded them:

     define myrule
     target:
             echo built
     endef

     $(myrule)

   The above makefile results in the definition of a target 'target'
with prerequisites 'echo' and 'built', as if the makefile contained
'target: echo built', rather than a rule with a recipe.  Newlines still
present in a line after expansion is complete are ignored as normal
whitespace.

   In order to properly expand a multi-line macro you must use the
'eval' function: this causes the 'make' parser to be run on the results
of the expanded macro (*note Eval Function::).

3.9 Secondary Expansion
=======================

Previously we learned that GNU 'make' works in two distinct phases: a
read-in phase and a target-update phase (*note How 'make' Reads a
Makefile: Reading Makefiles.).  GNU Make also has the ability to enable
a _second expansion_ of the prerequisites (only) for some or all targets
defined in the makefile.  In order for this second expansion to occur,
the special target '.SECONDEXPANSION' must be defined before the first
prerequisite list that makes use of this feature.

   If '.SECONDEXPANSION' is defined then when GNU 'make' needs to check
the prerequisites of a target, the prerequisites are expanded a _second
time_.  In most circumstances this secondary expansion will have no
effect, since all variable and function references will have been
expanded during the initial parsing of the makefiles.  In order to take
advantage of the secondary expansion phase of the parser, then, it's
necessary to _escape_ the variable or function reference in the
makefile.  In this case the first expansion merely un-escapes the
reference but doesn't expand it, and expansion is left to the secondary
expansion phase.  For example, consider this makefile:

     .SECONDEXPANSION:
     ONEVAR = onefile
     TWOVAR = twofile
     myfile: $(ONEVAR) $$(TWOVAR)

   After the first expansion phase the prerequisites list of the
'myfile' target will be 'onefile' and '$(TWOVAR)'; the first (unescaped)
variable reference to ONEVAR is expanded, while the second (escaped)
variable reference is simply unescaped, without being recognized as a
variable reference.  Now during the secondary expansion the first word
is expanded again but since it contains no variable or function
references it remains the value 'onefile', while the second word is now
a normal reference to the variable TWOVAR, which is expanded to the
value 'twofile'.  The final result is that there are two prerequisites,
'onefile' and 'twofile'.

   Obviously, this is not a very interesting case since the same result
could more easily have been achieved simply by having both variables
appear, unescaped, in the prerequisites list.  One difference becomes
apparent if the variables are reset; consider this example:

     .SECONDEXPANSION:
     AVAR = top
     onefile: $(AVAR)
     twofile: $$(AVAR)
     AVAR = bottom

   Here the prerequisite of 'onefile' will be expanded immediately, and
resolve to the value 'top', while the prerequisite of 'twofile' will not
be full expanded until the secondary expansion and yield a value of
'bottom'.

   This is marginally more exciting, but the true power of this feature
only becomes apparent when you discover that secondary expansions always
take place within the scope of the automatic variables for that target.
This means that you can use variables such as '$@', '$*', etc.  during
the second expansion and they will have their expected values, just as
in the recipe.  All you have to do is defer the expansion by escaping
the '$'.  Also, secondary expansion occurs for both explicit and
implicit (pattern) rules.  Knowing this, the possible uses for this
feature increase dramatically.  For example:

     .SECONDEXPANSION:
     main_OBJS := main.o try.o test.o
     lib_OBJS := lib.o api.o

     main lib: $$($$@_OBJS)

   Here, after the initial expansion the prerequisites of both the
'main' and 'lib' targets will be '$($@_OBJS)'.  During the secondary
expansion, the '$@' variable is set to the name of the target and so the
expansion for the 'main' target will yield '$(main_OBJS)', or 'main.o
try.o test.o', while the secondary expansion for the 'lib' target will
yield '$(lib_OBJS)', or 'lib.o api.o'.

   You can also mix in functions here, as long as they are properly
escaped:

     main_SRCS := main.c try.c test.c
     lib_SRCS := lib.c api.c

     .SECONDEXPANSION:
     main lib: $$(patsubst %.c,%.o,$$($$@_SRCS))

   This version allows users to specify source files rather than object
files, but gives the same resulting prerequisites list as the previous
example.

   Evaluation of automatic variables during the secondary expansion
phase, especially of the target name variable '$$@', behaves similarly
to evaluation within recipes.  However, there are some subtle
differences and "corner cases" which come into play for the different
types of rule definitions that 'make' understands.  The subtleties of
using the different automatic variables are described below.

Secondary Expansion of Explicit Rules
-------------------------------------

During the secondary expansion of explicit rules, '$$@' and '$$%'
evaluate, respectively, to the file name of the target and, when the
target is an archive member, the target member name.  The '$$<' variable
evaluates to the first prerequisite in the first rule for this target.
'$$^' and '$$+' evaluate to the list of all prerequisites of rules _that
have already appeared_ for the same target ('$$+' with repetitions and
'$$^' without).  The following example will help illustrate these
behaviors:

     .SECONDEXPANSION:

     foo: foo.1 bar.1 $$< $$^ $$+    # line #1

     foo: foo.2 bar.2 $$< $$^ $$+    # line #2

     foo: foo.3 bar.3 $$< $$^ $$+    # line #3

   In the first prerequisite list, all three variables ('$$<', '$$^',
and '$$+') expand to the empty string.  In the second, they will have
values 'foo.1', 'foo.1 bar.1', and 'foo.1 bar.1' respectively.  In the
third they will have values 'foo.1', 'foo.1 bar.1 foo.2 bar.2', and
'foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1' respectively.

   Rules undergo secondary expansion in makefile order, except that the
rule with the recipe is always evaluated last.

   The variables '$$?' and '$$*' are not available and expand to the
empty string.

Secondary Expansion of Static Pattern Rules
-------------------------------------------

Rules for secondary expansion of static pattern rules are identical to
those for explicit rules, above, with one exception: for static pattern
rules the '$$*' variable is set to the pattern stem.  As with explicit
rules, '$$?' is not available and expands to the empty string.

Secondary Expansion of Implicit Rules
-------------------------------------

As 'make' searches for an implicit rule, it substitutes the stem and
then performs secondary expansion for every rule with a matching target
pattern.  The value of the automatic variables is derived in the same
fashion as for static pattern rules.  As an example:

     .SECONDEXPANSION:

     foo: bar

     foo foz: fo%: bo%

     %oo: $$< $$^ $$+ $$*

   When the implicit rule is tried for target 'foo', '$$<' expands to
'bar', '$$^' expands to 'bar boo', '$$+' also expands to 'bar boo', and
'$$*' expands to 'f'.

   Note that the directory prefix (D), as described in *note Implicit
Rule Search Algorithm: Implicit Rule Search, is appended (after
expansion) to all the patterns in the prerequisites list.  As an
example:

     .SECONDEXPANSION:

     /tmp/foo.o:

     %.o: $$(addsuffix /%.c,foo bar) foo.h
             @echo $^

   The prerequisite list printed, after the secondary expansion and
directory prefix reconstruction, will be '/tmp/foo/foo.c /tmp/bar/foo.c
foo.h'.  If you are not interested in this reconstruction, you can use
'$$*' instead of '%' in the prerequisites list.

4 Writing Rules
***************

A "rule" appears in the makefile and says when and how to remake certain
files, called the rule's "targets" (most often only one per rule).  It
lists the other files that are the "prerequisites" of the target, and
the "recipe" to use to create or update the target.

   The order of rules is not significant, except for determining the
"default goal": the target for 'make' to consider, if you do not
otherwise specify one.  The default goal is the first target of the
first rule in the first makefile.  There are two exceptions: a target
starting with a period is not a default unless it also contains one or
more slashes, '/'; and, a target that defines a pattern rule has no
effect on the default goal.  (*Note Defining and Redefining Pattern
Rules: Pattern Rules.)

   Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs described
by the makefile (often with a target called 'all').  *Note Arguments to
Specify the Goals: Goals.

4.1 Rule Example
================

Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

   Its target is 'foo.o' and its prerequisites are 'foo.c' and 'defs.h'.
It has one command in the recipe: 'cc -c -g foo.c'.  The recipe starts
with a tab to identify it as a recipe.

   This rule says two things:

   * How to decide whether 'foo.o' is out of date: it is out of date if
     it does not exist, or if either 'foo.c' or 'defs.h' is more recent
     than it.

   * How to update the file 'foo.o': by running 'cc' as stated.  The
     recipe does not explicitly mention 'defs.h', but we presume that
     'foo.c' includes it, and that is why 'defs.h' was added to the
     prerequisites.

4.2 Rule Syntax
===============

In general, a rule looks like this:

     TARGETS : PREREQUISITES
             RECIPE
             ...

or like this:

     TARGETS : PREREQUISITES ; RECIPE
             RECIPE
             ...

   The TARGETS are file names, separated by spaces.  Wildcard characters
may be used (*note Using Wildcard Characters in File Names: Wildcards.)
and a name of the form 'A(M)' represents member M in archive file A
(*note Archive Members as Targets: Archive Members.).  Usually there is
only one target per rule, but occasionally there is a reason to have
more (*note Multiple Targets in a Rule: Multiple Targets.).

   The RECIPE lines start with a tab character (or the first character
in the value of the '.RECIPEPREFIX' variable; *note Special
Variables::).  The first recipe line may appear on the line after the
prerequisites, with a tab character, or may appear on the same line,
with a semicolon.  Either way, the effect is the same.  There are other
differences in the syntax of recipes.  *Note Writing Recipes in Rules:
Recipes.

   Because dollar signs are used to start 'make' variable references, if
you really want a dollar sign in a target or prerequisite you must write
two of them, '$$' (*note How to Use Variables: Using Variables.).  If
you have enabled secondary expansion (*note Secondary Expansion::) and
you want a literal dollar sign in the prerequisites list, you must
actually write _four_ dollar signs ('$$$$').

   You may split a long line by inserting a backslash followed by a
newline, but this is not required, as 'make' places no limit on the
length of a line in a makefile.

   A rule tells 'make' two things: when the targets are out of date, and
how to update them when necessary.

   The criterion for being out of date is specified in terms of the
PREREQUISITES, which consist of file names separated by spaces.
(Wildcards and archive members (*note Archives::) are allowed here too.)
A target is out of date if it does not exist or if it is older than any
of the prerequisites (by comparison of last-modification times).  The
idea is that the contents of the target file are computed based on
information in the prerequisites, so if any of the prerequisites
changes, the contents of the existing target file are no longer
necessarily valid.

   How to update is specified by a RECIPE.  This is one or more lines to
be executed by the shell (normally 'sh'), but with some extra features
(*note Writing Recipes in Rules: Recipes.).

4.3 Types of Prerequisites
==========================

There are two different types of prerequisites understood by GNU 'make':
normal prerequisites, described in the previous section, and
"order-only" prerequisites.  A normal prerequisite makes two statements:
first, it imposes an order in which recipes will be invoked: the recipes
for all prerequisites of a target will be completed before the recipe
for the target is started.  Second, it imposes a dependency
relationship: if any prerequisite is newer than the target, then the
target is considered out-of-date and must be rebuilt.

   Normally, this is exactly what you want: if a target's prerequisite
is updated, then the target should also be updated.

   Occasionally you may want to ensure that a prerequisite is built
before a target, but _without_ forcing the target to be updated if the
prerequisite is updated.  "Order-only" prerequisites are used to create
this type of relationship.  Order-only prerequisites can be specified by
placing a pipe symbol ('|') in the prerequisites list: any prerequisites
to the left of the pipe symbol are normal; any prerequisites to the
right are order-only:

     TARGETS : NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES

   The normal prerequisites section may of course be empty.  Also, you
may still declare multiple lines of prerequisites for the same target:
they are appended appropriately (normal prerequisites are appended to
the list of normal prerequisites; order-only prerequisites are appended
to the list of order-only prerequisites).  Note that if you declare the
same file to be both a normal and an order-only prerequisite, the normal
prerequisite takes precedence (since they have a strict superset of the
behavior of an order-only prerequisite).

   Order-only prerequisites are never checked when determining if the
target is out of date; even order-only prerequisites marked as phony
(*note Phony Targets::) will not cause the target to be rebuilt.

   Consider an example where your targets are to be placed in a separate
directory, and that directory might not exist before 'make' is run.  In
this situation, you want the directory to be created before any targets
are placed into it but, because the timestamps on directories change
whenever a file is added, removed, or renamed, we certainly don't want
to rebuild all the targets whenever the directory's timestamp changes.
One way to manage this is with order-only prerequisites: make the
directory an order-only prerequisite on all the targets:

     OBJDIR := objdir
     OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)

     $(OBJDIR)/%.o : %.c
             $(COMPILE.c) $(OUTPUT_OPTION) $<

     all: $(OBJS)

     $(OBJS): | $(OBJDIR)

     $(OBJDIR):
             mkdir $(OBJDIR)

   Now the rule to create the 'objdir' directory will be run, if needed,
before any '.o' is built, but no '.o' will be built because the 'objdir'
directory timestamp changed.

4.4 Using Wildcard Characters in File Names
===========================================

A single file name can specify many files using "wildcard characters".
The wildcard characters in 'make' are '*', '?' and '[...]', the same as
in the Bourne shell.  For example, '*.c' specifies a list of all the
files (in the working directory) whose names end in '.c'.

   If an expression matches multiple files then the results will be
sorted.(1)  However multiple expressions will not be globally sorted.
For example, '*.c *.h' will list all the files whose names end in '.c',
sorted, followed by all the files whose names end in '.h', sorted.

   The character '~' at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example '~/bin' expands to '/home/you/bin'.  If the '~'
is followed by a word, the string represents the home directory of the
user named by that word.  For example '~john/bin' expands to
'/home/john/bin'.  On systems which don't have a home directory for each
user (such as MS-DOS or MS-Windows), this functionality can be simulated
by setting the environment variable HOME.

   Wildcard expansion is performed by 'make' automatically in targets
and in prerequisites.  In recipes, the shell is responsible for wildcard
expansion.  In other contexts, wildcard expansion happens only if you
request it explicitly with the 'wildcard' function.

   The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, 'foo\*bar' would refer to a
specific file whose name consists of 'foo', an asterisk, and 'bar'.

   ---------- Footnotes ----------

   (1) Some older versions of GNU 'make' did not sort the results of
wildcard expansion.

4.4.1 Wildcard Examples
-----------------------

Wildcards can be used in the recipe of a rule, where they are expanded
by the shell.  For example, here is a rule to delete all the object
files:

     clean:
             rm -f *.o

   Wildcards are also useful in the prerequisites of a rule.  With the
following rule in the makefile, 'make print' will print all the '.c'
files that have changed since the last time you printed them:

     print: *.c
             lpr -p $?
             touch print

This rule uses 'print' as an empty target file; see *note Empty Target
Files to Record Events: Empty Targets.  (The automatic variable '$?' is
used to print only those files that have changed; see *note Automatic
Variables::.)

   Wildcard expansion does not happen when you define a variable.  Thus,
if you write this:

     objects = *.o

then the value of the variable 'objects' is the actual string '*.o'.
However, if you use the value of 'objects' in a target or prerequisite,
wildcard expansion will take place there.  If you use the value of
'objects' in a recipe, the shell may perform wildcard expansion when the
recipe runs.  To set 'objects' to the expansion, instead use:

     objects := $(wildcard *.o)

*Note Wildcard Function::.

4.4.2 Pitfalls of Using Wildcards
---------------------------------

Now here is an example of a naive way of using wildcard expansion, that
does not do what you would intend.  Suppose you would like to say that
the executable file 'foo' is made from all the object files in the
directory, and you write this:

     objects = *.o

     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of 'objects' is the actual string '*.o'.  Wildcard expansion
happens in the rule for 'foo', so that each _existing_ '.o' file becomes
a prerequisite of 'foo' and will be recompiled if necessary.

   But what if you delete all the '.o' files?  When a wildcard matches
no files, it is left as it is, so then 'foo' will depend on the
oddly-named file '*.o'.  Since no such file is likely to exist, 'make'
will give you an error saying it cannot figure out how to make '*.o'.
This is not what you want!

   Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
'wildcard' function and string substitution.  *Note The Function
'wildcard': Wildcard Function.

   Microsoft operating systems (MS-DOS and MS-Windows) use backslashes
to separate directories in pathnames, like so:

       c:\foo\bar\baz.c

   This is equivalent to the Unix-style 'c:/foo/bar/baz.c' (the 'c:'
part is the so-called drive letter).  When 'make' runs on these systems,
it supports backslashes as well as the Unix-style forward slashes in
pathnames.  However, this support does _not_ include the wildcard
expansion, where backslash is a quote character.  Therefore, you _must_
use Unix-style slashes in these cases.

4.4.3 The Function 'wildcard'
-----------------------------

Wildcard expansion happens automatically in rules.  But wildcard
expansion does not normally take place when a variable is set, or inside
the arguments of a function.  If you want to do wildcard expansion in
such places, you need to use the 'wildcard' function, like this:

     $(wildcard PATTERN...)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output of the 'wildcard' function.
Note that this is different from how unmatched wildcards behave in
rules, where they are used verbatim rather than ignored (*note Wildcard
Pitfall::).

   As with wildcard expansion in rules, the results of the 'wildcard'
function are sorted.  But again, each individual expression is sorted
separately, so '$(wildcard *.c *.h)' will expand to all files matching
'.c', sorted, followed by all files matching '.h', sorted.

   One use of the 'wildcard' function is to get a list of all the C
source files in a directory, like this:

     $(wildcard *.c)

   We can change the list of C source files into a list of object files
by replacing the '.c' suffix with '.o' in the result, like this:

     $(patsubst %.c,%.o,$(wildcard *.c))

(Here we have used another function, 'patsubst'.  *Note Functions for
String Substitution and Analysis: Text Functions.)

   Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects := $(patsubst %.c,%.o,$(wildcard *.c))

     foo : $(objects)
             cc -o foo $(objects)

(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.  *Note
The Two Flavors of Variables: Flavors, for an explanation of ':=', which
is a variant of '='.)

4.5 Searching Directories for Prerequisites
===========================================

For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The "directory search" features of 'make'
facilitate this by searching several directories automatically to find a
prerequisite.  When you redistribute the files among directories, you do
not need to change the individual rules, just the search paths.

4.5.1 'VPATH': Search Path for All Prerequisites
------------------------------------------------

The value of the 'make' variable 'VPATH' specifies a list of directories
that 'make' should search.  Most often, the directories are expected to
contain prerequisite files that are not in the current directory;
however, 'make' uses 'VPATH' as a search list for both prerequisites and
targets of rules.

   Thus, if a file that is listed as a target or prerequisite does not
exist in the current directory, 'make' searches the directories listed
in 'VPATH' for a file with that name.  If a file is found in one of
them, that file may become the prerequisite (see below).  Rules may then
specify the names of files in the prerequisite list as if they all
existed in the current directory.  *Note Writing Recipes with Directory
Search: Recipes/Search.

   In the 'VPATH' variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by 'make' in its search.  (On MS-DOS and MS-Windows, semi-colons are
used as separators of directory names in 'VPATH', since the colon can be
used in the pathname itself, after the drive letter.)

   For example,

     VPATH = src:../headers

specifies a path containing two directories, 'src' and '../headers',
which 'make' searches in that order.

   With this value of 'VPATH', the following rule,

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file 'foo.c' does not exist in the current directory but is
found in the directory 'src'.

4.5.2 The 'vpath' Directive
---------------------------

Similar to the 'VPATH' variable, but more selective, is the 'vpath'
directive (note lower case), which allows you to specify a search path
for a particular class of file names: those that match a particular
pattern.  Thus you can supply certain search directories for one class
of file names and other directories (or none) for other file names.

   There are three forms of the 'vpath' directive:

'vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for file names that match
     PATTERN.

     The search path, DIRECTORIES, is a list of directories to be
     searched, separated by colons (semi-colons on MS-DOS and
     MS-Windows) or blanks, just like the search path used in the
     'VPATH' variable.

'vpath PATTERN'
     Clear out the search path associated with PATTERN.

'vpath'

     Clear all search paths previously specified with 'vpath'
     directives.

   A 'vpath' pattern is a string containing a '%' character.  The string
must match the file name of a prerequisite that is being searched for,
the '%' character matching any sequence of zero or more characters (as
in pattern rules; *note Defining and Redefining Pattern Rules: Pattern
Rules.).  For example, '%.h' matches files that end in '.h'.  (If there
is no '%', the pattern must match the prerequisite exactly, which is not
useful very often.)

   '%' characters in a 'vpath' directive's pattern can be quoted with
preceding backslashes ('\').  Backslashes that would otherwise quote '%'
characters can be quoted with more backslashes.  Backslashes that quote
'%' characters or other backslashes are removed from the pattern before
it is compared to file names.  Backslashes that are not in danger of
quoting '%' characters go unmolested.

   When a prerequisite fails to exist in the current directory, if the
PATTERN in a 'vpath' directive matches the name of the prerequisite
file, then the DIRECTORIES in that directive are searched just like (and
before) the directories in the 'VPATH' variable.

   For example,

     vpath %.h ../headers

tells 'make' to look for any prerequisite whose name ends in '.h' in the
directory '../headers' if the file is not found in the current
directory.

   If several 'vpath' patterns match the prerequisite file's name, then
'make' processes each matching 'vpath' directive one by one, searching
all the directories mentioned in each directive.  'make' handles
multiple 'vpath' directives in the order in which they appear in the
makefile; multiple directives with the same pattern are independent of
each other.

   Thus,

     vpath %.c foo
     vpath %   blish
     vpath %.c bar

will look for a file ending in '.c' in 'foo', then 'blish', then 'bar',
while

     vpath %.c foo:bar
     vpath %   blish

will look for a file ending in '.c' in 'foo', then 'bar', then 'blish'.

4.5.3 How Directory Searches are Performed
------------------------------------------

When a prerequisite is found through directory search, regardless of
type (general or selective), the pathname located may not be the one
that 'make' actually provides you in the prerequisite list.  Sometimes
the path discovered through directory search is thrown away.

   The algorithm 'make' uses to decide whether to keep or abandon a path
found via directory search is as follows:

  1. If a target file does not exist at the path specified in the
     makefile, directory search is performed.

  2. If the directory search is successful, that path is kept and this
     file is tentatively stored as the target.

  3. All prerequisites of this target are examined using this same
     method.

  4. After processing the prerequisites, the target may or may not need
     to be rebuilt:

       a. If the target does _not_ need to be rebuilt, the path to the
          file found during directory search is used for any
          prerequisite lists which contain this target.  In short, if
          'make' doesn't need to rebuild the target then you use the
          path found via directory search.

       b. If the target _does_ need to be rebuilt (is out-of-date), the
          pathname found during directory search is _thrown away_, and
          the target is rebuilt using the file name specified in the
          makefile.  In short, if 'make' must rebuild, then the target
          is rebuilt locally, not in the directory found via directory
          search.

   This algorithm may seem complex, but in practice it is quite often
exactly what you want.

   Other versions of 'make' use a simpler algorithm: if the file does
not exist, and it is found via directory search, then that pathname is
always used whether or not the target needs to be built.  Thus, if the
target is rebuilt it is created at the pathname discovered during
directory search.

   If, in fact, this is the behavior you want for some or all of your
directories, you can use the 'GPATH' variable to indicate this to
'make'.

   'GPATH' has the same syntax and format as 'VPATH' (that is, a space-
or colon-delimited list of pathnames).  If an out-of-date target is
found by directory search in a directory that also appears in 'GPATH',
then that pathname is not thrown away.  The target is rebuilt using the
expanded path.

4.5.4 Writing Recipes with Directory Search
-------------------------------------------

When a prerequisite is found in another directory through directory
search, this cannot change the recipe of the rule; they will execute as
written.  Therefore, you must write the recipe with care so that it will
look for the prerequisite in the directory where 'make' finds it.

   This is done with the "automatic variables" such as '$^' (*note
Automatic Variables::).  For instance, the value of '$^' is a list of
all the prerequisites of the rule, including the names of the
directories in which they were found, and the value of '$@' is the
target.  Thus:

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

(The variable 'CFLAGS' exists so you can specify flags for C compilation
by implicit rules; we use it here for consistency so it will affect all
C compilations uniformly; *note Variables Used by Implicit Rules:
Implicit Variables.)

   Often the prerequisites include header files as well, which you do
not want to mention in the recipe.  The automatic variable '$<' is just
the first prerequisite:

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $< -o $@

4.5.5 Directory Search and Implicit Rules
-----------------------------------------

The search through the directories specified in 'VPATH' or with 'vpath'
also happens during consideration of implicit rules (*note Using
Implicit Rules: Implicit Rules.).

   For example, when a file 'foo.o' has no explicit rule, 'make'
considers implicit rules, such as the built-in rule to compile 'foo.c'
if that file exists.  If such a file is lacking in the current
directory, the appropriate directories are searched for it.  If 'foo.c'
exists (or is mentioned in the makefile) in any of the directories, the
implicit rule for C compilation is applied.

   The recipes of implicit rules normally use automatic variables as a
matter of necessity; consequently they will use the file names found by
directory search with no extra effort.

4.5.6 Directory Search for Link Libraries
-----------------------------------------

Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a
prerequisite whose name is of the form '-lNAME'.  (You can tell
something strange is going on here because the prerequisite is normally
the name of a file, and the _file name_ of a library generally looks
like 'libNAME.a', not like '-lNAME'.)

   When a prerequisite's name has the form '-lNAME', 'make' handles it
specially by searching for the file 'libNAME.so', and, if it is not
found, for the file 'libNAME.a' in the current directory, in directories
specified by matching 'vpath' search paths and the 'VPATH' search path,
and then in the directories '/lib', '/usr/lib', and 'PREFIX/lib'
(normally '/usr/local/lib', but MS-DOS/MS-Windows versions of 'make'
behave as if PREFIX is defined to be the root of the DJGPP installation
tree).

   For example, if there is a '/usr/lib/libcurses.a' library on your
system (and no '/usr/lib/libcurses.so' file), then

     foo : foo.c -lcurses
             cc $^ -o $@

would cause the command 'cc foo.c /usr/lib/libcurses.a -o foo' to be
executed when 'foo' is older than 'foo.c' or than
'/usr/lib/libcurses.a'.

   Although the default set of files to be searched for is 'libNAME.so'
and 'libNAME.a', this is customizable via the '.LIBPATTERNS' variable.
Each word in the value of this variable is a pattern string.  When a
prerequisite like '-lNAME' is seen, 'make' will replace the percent in
each pattern in the list with NAME and perform the above directory
searches using each library file name.

   The default value for '.LIBPATTERNS' is 'lib%.so lib%.a', which
provides the default behavior described above.

   You can turn off link library expansion completely by setting this
variable to an empty value.

4.6 Phony Targets
=================

A phony target is one that is not really the name of a file; rather it
is just a name for a recipe to be executed when you make an explicit
request.  There are two reasons to use a phony target: to avoid a
conflict with a file of the same name, and to improve performance.

   If you write a rule whose recipe will not create the target file, the
recipe will be executed every time the target comes up for remaking.
Here is an example:

     clean:
             rm *.o temp

Because the 'rm' command does not create a file named 'clean', probably
no such file will ever exist.  Therefore, the 'rm' command will be
executed every time you say 'make clean'.

   In this example, the 'clean' target will not work properly if a file
named 'clean' is ever created in this directory.  Since it has no
prerequisites, 'clean' would always be considered up to date and its
recipe would not be executed.  To avoid this problem you can explicitly
declare the target to be phony by making it a prerequisite of the
special target '.PHONY' (*note Special Built-in Target Names: Special
Targets.) as follows:

     .PHONY: clean
     clean:
             rm *.o temp

Once this is done, 'make clean' will run the recipe regardless of
whether there is a file named 'clean'.

   Prerequisites of '.PHONY' are always interpreted as literal target
names, never as patterns (even if they contain '%' characters).  To
always rebuild a pattern rule consider using a "force target" (*note
Rules without Recipes or Prerequisites: Force Targets.).

   Phony targets are also useful in conjunction with recursive
invocations of 'make' (*note Recursive Use of 'make': Recursion.).  In
this situation the makefile will often contain a variable which lists a
number of sub-directories to be built.  A simplistic way to handle this
is to define one rule with a recipe that loops over the sub-directories,
like this:

     SUBDIRS = foo bar baz

     subdirs:
             for dir in $(SUBDIRS); do \
               $(MAKE) -C $$dir; \
             done

   There are problems with this method, however.  First, any error
detected in a sub-make is ignored by this rule, so it will continue to
build the rest of the directories even when one fails.  This can be
overcome by adding shell commands to note the error and exit, but then
it will do so even if 'make' is invoked with the '-k' option, which is
unfortunate.  Second, and perhaps more importantly, you cannot take full
advantage of 'make''s ability to build targets in parallel (*note
Parallel Execution: Parallel.), since there is only one rule.  Each
individual makefile's targets will be built in parallel, but only one
sub-directory will be built at a time.

   By declaring the sub-directories as '.PHONY' targets (you must do
this as the sub-directory obviously always exists; otherwise it won't be
built) you can remove these problems:

     SUBDIRS = foo bar baz

     .PHONY: subdirs $(SUBDIRS)

     subdirs: $(SUBDIRS)

     $(SUBDIRS):
             $(MAKE) -C $@

     foo: baz

   Here we've also declared that the 'foo' sub-directory cannot be built
until after the 'baz' sub-directory is complete; this kind of
relationship declaration is particularly important when attempting
parallel builds.

   The implicit rule search (*note Implicit Rules::) is skipped for
'.PHONY' targets.  This is why declaring a target as '.PHONY' is good
for performance, even if you are not worried about the actual file
existing.

   A phony target should not be a prerequisite of a real target file; if
it is, its recipe will be run every time 'make' considers that file.  As
long as a phony target is never a prerequisite of a real target, the
phony target recipe will be executed only when the phony target is a
specified goal (*note Arguments to Specify the Goals: Goals.).

   You should not declare an included makefile as phony.  Phony targets
are not intended to represent real files, and because the target is
always considered out of date make will always rebuild it then
re-execute itself (*note How Makefiles Are Remade: Remaking Makefiles.).
To avoid this, 'make' will not re-execute itself if an included file
marked as phony is re-built.

   Phony targets can have prerequisites.  When one directory contains
multiple programs, it is most convenient to describe all of the programs
in one makefile './Makefile'.  Since the target remade by default will
be the first one in the makefile, it is common to make this a phony
target named 'all' and give it, as prerequisites, all the individual
programs.  For example:

     all : prog1 prog2 prog3
     .PHONY : all

     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o

     prog2 : prog2.o
             cc -o prog2 prog2.o

     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o

Now you can say just 'make' to remake all three programs, or specify as
arguments the ones to remake (as in 'make prog1 prog3').  Phoniness is
not inherited: the prerequisites of a phony target are not themselves
phony, unless explicitly declared to be so.

   When one phony target is a prerequisite of another, it serves as a
subroutine of the other.  For example, here 'make cleanall' will delete
the object files, the difference files, and the file 'program':

     .PHONY: cleanall cleanobj cleandiff

     cleanall : cleanobj cleandiff
             rm program

     cleanobj :
             rm *.o

     cleandiff :
             rm *.diff

4.7 Rules without Recipes or Prerequisites
==========================================

If a rule has no prerequisites or recipe, and the target of the rule is
a nonexistent file, then 'make' imagines this target to have been
updated whenever its rule is run.  This implies that all targets
depending on this one will always have their recipe run.

   An example will illustrate this:

     clean: FORCE
             rm $(objects)
     FORCE:

   Here the target 'FORCE' satisfies the special conditions, so the
target 'clean' that depends on it is forced to run its recipe.  There is
nothing special about the name 'FORCE', but that is one name commonly
used this way.

   As you can see, using 'FORCE' this way has the same results as using
'.PHONY: clean'.

   Using '.PHONY' is more explicit and more efficient.  However, other
versions of 'make' do not support '.PHONY'; thus 'FORCE' appears in many
makefiles.  *Note Phony Targets::.

4.8 Empty Target Files to Record Events
=======================================

The "empty target" is a variant of the phony target; it is used to hold
recipes for an action that you request explicitly from time to time.
Unlike a phony target, this target file can really exist; but the file's
contents do not matter, and usually are empty.

   The purpose of the empty target file is to record, with its
last-modification time, when the rule's recipe was last executed.  It
does so because one of the commands in the recipe is a 'touch' command
to update the target file.

   The empty target file should have some prerequisites (otherwise it
doesn't make sense).  When you ask to remake the empty target, the
recipe is executed if any prerequisite is more recent than the target;
in other words, if a prerequisite has changed since the last time you
remade the target.  Here is an example:

     print: foo.c bar.c
             lpr -p $?
             touch print

With this rule, 'make print' will execute the 'lpr' command if either
source file has changed since the last 'make print'.  The automatic
variable '$?' is used to print only those files that have changed (*note
Automatic Variables::).

4.9 Special Built-in Target Names
=================================

Certain names have special meanings if they appear as targets.

'.PHONY'

     The prerequisites of the special target '.PHONY' are considered to
     be phony targets.  When it is time to consider such a target,
     'make' will run its recipe unconditionally, regardless of whether a
     file with that name exists or what its last-modification time is.
     *Note Phony Targets: Phony Targets.

'.SUFFIXES'

     The prerequisites of the special target '.SUFFIXES' are the list of
     suffixes to be used in checking for suffix rules.  *Note
     Old-Fashioned Suffix Rules: Suffix Rules.

'.DEFAULT'

     The recipe specified for '.DEFAULT' is used for any target for
     which no rules are found (either explicit rules or implicit rules).
     *Note Last Resort::.  If a '.DEFAULT' recipe is specified, every
     file mentioned as a prerequisite, but not as a target in a rule,
     will have that recipe executed on its behalf.  *Note Implicit Rule
     Search Algorithm: Implicit Rule Search.

'.PRECIOUS'

     The targets which '.PRECIOUS' depends on are given the following
     special treatment: if 'make' is killed or interrupted during the
     execution of their recipes, the target is not deleted.  *Note
     Interrupting or Killing 'make': Interrupts.  Also, if the target is
     an intermediate file, it will not be deleted after it is no longer
     needed, as is normally done.  *Note Chains of Implicit Rules:
     Chained Rules.  In this latter respect it overlaps with the
     '.SECONDARY' special target.

     You can also list the target pattern of an implicit rule (such as
     '%.o') as a prerequisite file of the special target '.PRECIOUS' to
     preserve intermediate files created by rules whose target patterns
     match that file's name.

'.INTERMEDIATE'

     The targets which '.INTERMEDIATE' depends on are treated as
     intermediate files.  *Note Chains of Implicit Rules: Chained Rules.
     '.INTERMEDIATE' with no prerequisites has no effect.

'.NOTINTERMEDIATE'

     Prerequisites of the special target '.NOTINTERMEDIATE' are never
     considered intermediate files.  *Note Chains of Implicit Rules:
     Chained Rules.  '.NOTINTERMEDIATE' with no prerequisites causes all
     targets to be treated as not intermediate.

     If the prerequisite is a target pattern then targets that are built
     using that pattern rule are not considered intermediate.

'.SECONDARY'

     The targets which '.SECONDARY' depends on are treated as
     intermediate files, except that they are never automatically
     deleted.  *Note Chains of Implicit Rules: Chained Rules.

     '.SECONDARY' can be used to avoid redundant rebuilds in some
     unusual situations.  For example:

          hello.bin: hello.o bye.o
                  $(CC) -o $@ $^

          %.o: %.c
                  $(CC) -c -o $@ $<

          .SECONDARY: hello.o bye.o

     Suppose 'hello.bin' is up to date in regards to the source files,
     _but_ the object file 'hello.o' is missing.  Without '.SECONDARY'
     make would rebuild 'hello.o' then rebuild 'hello.bin' even though
     the source files had not changed.  By declaring 'hello.o' as
     '.SECONDARY' 'make' will not need to rebuild it and won't need to
     rebuild 'hello.bin' either.  Of course, if one of the source files
     _were_ updated then all object files would be rebuilt so that the
     creation of 'hello.bin' could succeed.

     '.SECONDARY' with no prerequisites causes all targets to be treated
     as secondary (i.e., no target is removed because it is considered
     intermediate).

'.SECONDEXPANSION'

     If '.SECONDEXPANSION' is mentioned as a target anywhere in the
     makefile, then all prerequisite lists defined _after_ it appears
     will be expanded a second time after all makefiles have been read
     in.  *Note Secondary Expansion: Secondary Expansion.

'.DELETE_ON_ERROR'

     If '.DELETE_ON_ERROR' is mentioned as a target anywhere in the
     makefile, then 'make' will delete the target of a rule if it has
     changed and its recipe exits with a nonzero exit status, just as it
     does when it receives a signal.  *Note Errors in Recipes: Errors.

'.IGNORE'

     If you specify prerequisites for '.IGNORE', then 'make' will ignore
     errors in execution of the recipe for those particular files.  The
     recipe for '.IGNORE' (if any) is ignored.

     If mentioned as a target with no prerequisites, '.IGNORE' says to
     ignore errors in execution of recipes for all files.  This usage of
     '.IGNORE' is supported only for historical compatibility.  Since
     this affects every recipe in the makefile, it is not very useful;
     we recommend you use the more selective ways to ignore errors in
     specific recipes.  *Note Errors in Recipes: Errors.

'.LOW_RESOLUTION_TIME'

     If you specify prerequisites for '.LOW_RESOLUTION_TIME', 'make'
     assumes that these files are created by commands that generate low
     resolution time stamps.  The recipe for the '.LOW_RESOLUTION_TIME'
     target are ignored.

     The high resolution file time stamps of many modern file systems
     lessen the chance of 'make' incorrectly concluding that a file is
     up to date.  Unfortunately, some hosts do not provide a way to set
     a high resolution file time stamp, so commands like 'cp -p' that
     explicitly set a file's time stamp must discard its sub-second
     part.  If a file is created by such a command, you should list it
     as a prerequisite of '.LOW_RESOLUTION_TIME' so that 'make' does not
     mistakenly conclude that the file is out of date.  For example:

          .LOW_RESOLUTION_TIME: dst
          dst: src
                  cp -p src dst

     Since 'cp -p' discards the sub-second part of 'src''s time stamp,
     'dst' is typically slightly older than 'src' even when it is up to
     date.  The '.LOW_RESOLUTION_TIME' line causes 'make' to consider
     'dst' to be up to date if its time stamp is at the start of the
     same second that 'src''s time stamp is in.

     Due to a limitation of the archive format, archive member time
     stamps are always low resolution.  You need not list archive
     members as prerequisites of '.LOW_RESOLUTION_TIME', as 'make' does
     this automatically.

'.SILENT'

     If you specify prerequisites for '.SILENT', then 'make' will not
     print the recipe used to remake those particular files before
     executing them.  The recipe for '.SILENT' is ignored.

     If mentioned as a target with no prerequisites, '.SILENT' says not
     to print any recipes before executing them.  You may also use more
     selective ways to silence specific recipe command lines.  *Note
     Recipe Echoing: Echoing.  If you want to silence all recipes for a
     particular run of 'make', use the '-s' or '--silent' option (*note
     Options Summary::).

'.EXPORT_ALL_VARIABLES'

     Simply by being mentioned as a target, this tells 'make' to export
     all variables to child processes by default.  This is an
     alternative to using 'export' with no arguments.  *Note
     Communicating Variables to a Sub-'make': Variables/Recursion.

'.NOTPARALLEL'

     If '.NOTPARALLEL' is mentioned as a target with no prerequisites,
     all targets in this invocation of 'make' will be run serially, even
     if the '-j' option is given.  Any recursively invoked 'make'
     command will still run recipes in parallel (unless its makefile
     also contains this target).

     If '.NOTPARALLEL' has targets as prerequisites, then all the
     prerequisites of those targets will be run serially.  This
     implicitly adds a '.WAIT' between each prerequisite of the listed
     targets.  *Note Disabling Parallel Execution: Parallel Disable.

'.ONESHELL'

     If '.ONESHELL' is mentioned as a target, then when a target is
     built all lines of the recipe will be given to a single invocation
     of the shell rather than each line being invoked separately.  *Note
     Recipe Execution: Execution.

'.POSIX'

     If '.POSIX' is mentioned as a target, then the makefile will be
     parsed and run in POSIX-conforming mode.  This does _not_ mean that
     only POSIX-conforming makefiles will be accepted: all advanced GNU
     'make' features are still available.  Rather, this target causes
     'make' to behave as required by POSIX in those areas where 'make''s
     default behavior differs.

     In particular, if this target is mentioned then recipes will be
     invoked as if the shell had been passed the '-e' flag: the first
     failing command in a recipe will cause the recipe to fail
     immediately.

   Any defined implicit rule suffix also counts as a special target if
it appears as a target, and so does the concatenation of two suffixes,
such as '.c.o'.  These targets are suffix rules, an obsolete way of
defining implicit rules (but a way still widely used).  In principle,
any target name could be special in this way if you break it in two and
add both pieces to the suffix list.  In practice, suffixes normally
begin with '.', so these special target names also begin with '.'.
*Note Old-Fashioned Suffix Rules: Suffix Rules.

4.10 Multiple Targets in a Rule
===============================

When an explicit rule has multiple targets they can be treated in one of
two possible ways: as independent targets or as grouped targets.  The
manner in which they are treated is determined by the separator that
appears after the list of targets.

Rules with Independent Targets
..............................

Rules that use the standard target separator, ':', define independent
targets.  This is equivalent to writing the same rule once for each
target, with duplicated prerequisites and recipes.  Typically, the
recipe would use automatic variables such as '$@' to specify which
target is being built.

   Rules with independent targets are useful in two cases:

   * You want just prerequisites, no recipe.  For example:

          kbd.o command.o files.o: command.h

     gives an additional prerequisite to each of the three object files
     mentioned.  It is equivalent to writing:

          kbd.o: command.h
          command.o: command.h
          files.o: command.h

   * Similar recipes work for all the targets.  The automatic variable
     '$@' can be used to substitute the particular target to be remade
     into the commands (*note Automatic Variables::).  For example:

          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) > $@

     is equivalent to

          bigoutput : text.g
                  generate text.g -big > bigoutput
          littleoutput : text.g
                  generate text.g -little > littleoutput

     Here we assume the hypothetical program 'generate' makes two types
     of output, one if given '-big' and one if given '-little'.  *Note
     Functions for String Substitution and Analysis: Text Functions, for
     an explanation of the 'subst' function.

   Suppose you would like to vary the prerequisites according to the
target, much as the variable '$@' allows you to vary the recipe.  You
cannot do this with multiple targets in an ordinary rule, but you can do
it with a "static pattern rule".  *Note Static Pattern Rules: Static
Pattern.

Rules with Grouped Targets
..........................

If instead of independent targets you have a recipe that generates
multiple files from a single invocation, you can express that
relationship by declaring your rule to use _grouped targets_.  A grouped
target rule uses the separator '&:' (the '&' here is used to imply
"all").

   When 'make' builds any one of the grouped targets, it understands
that all the other targets in the group are also updated as a result of
the invocation of the recipe.  Furthermore, if only some of the grouped
targets are out of date or missing 'make' will realize that running the
recipe will update all of the targets.  Finally, if any of the grouped
targets are out of date, all the grouped targets are considered out of
date.

   As an example, this rule defines a grouped target:

     foo bar biz &: baz boz
             echo $^ > foo
             echo $^ > bar
             echo $^ > biz

   During the execution of a grouped target's recipe, the automatic
variable '$@' is set to the name of the particular target in the group
which triggered the rule.  Caution must be used if relying on this
variable in the recipe of a grouped target rule.

   Unlike independent targets, a grouped target rule _must_ include a
recipe.  However, targets that are members of a grouped target may also
appear in independent target rule definitions that do not have recipes.

   Each target may have only one recipe associated with it.  If a
grouped target appears in either an independent target rule or in
another grouped target rule with a recipe, you will get a warning and
the latter recipe will replace the former recipe.  Additionally the
target will be removed from the previous group and appear only in the
new group.

   If you would like a target to appear in multiple groups, then you
must use the double-colon grouped target separator, '&::' when declaring
all of the groups containing that target.  Grouped double-colon targets
are each considered independently, and each grouped double-colon rule's
recipe is executed at most once, if at least one of its multiple targets
requires updating.

4.11 Multiple Rules for One Target
==================================

One file can be the target of several rules.  All the prerequisites
mentioned in all the rules are merged into one list of prerequisites for
the target.  If the target is older than any prerequisite from any rule,
the recipe is executed.

   There can only be one recipe to be executed for a file.  If more than
one rule gives a recipe for the same file, 'make' uses the last one
given and prints an error message.  (As a special case, if the file's
name begins with a dot, no error message is printed.  This odd behavior
is only for compatibility with other implementations of 'make'... you
should avoid using it).  Occasionally it is useful to have the same
target invoke multiple recipes which are defined in different parts of
your makefile; you can use "double-colon rules" (*note Double-Colon::)
for this.

   An extra rule with just prerequisites can be used to give a few extra
prerequisites to many files at once.  For example, makefiles often have
a variable, such as 'objects', containing a list of all the compiler
output files in the system being made.  An easy way to say that all of
them must be recompiled if 'config.h' changes is to write the following:

     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h

   This could be inserted or taken out without changing the rules that
really specify how to make the object files, making it a convenient form
to use if you wish to add the additional prerequisite intermittently.

   Another wrinkle is that the additional prerequisites could be
specified with a variable that you set with a command line argument to
'make' (*note Overriding Variables: Overriding.).  For example,

     extradeps=
     $(objects) : $(extradeps)

means that the command 'make extradeps=foo.h' will consider 'foo.h' as a
prerequisite of each object file, but plain 'make' will not.

   If none of the explicit rules for a target has a recipe, then 'make'
searches for an applicable implicit rule to find one *note Using
Implicit Rules: Implicit Rules.).

4.12 Static Pattern Rules
=========================

"Static pattern rules" are rules which specify multiple targets and
construct the prerequisite names for each target based on the target
name.  They are more general than ordinary rules with multiple targets
because the targets do not have to have identical prerequisites.  Their
prerequisites must be _analogous_, but not necessarily _identical_.

4.12.1 Syntax of Static Pattern Rules
-------------------------------------

Here is the syntax of a static pattern rule:

     TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...
             RECIPE
             ...

The TARGETS list specifies the targets that the rule applies to.  The
targets can contain wildcard characters, just like the targets of
ordinary rules (*note Using Wildcard Characters in File Names:
Wildcards.).

   The TARGET-PATTERN and PREREQ-PATTERNS say how to compute the
prerequisites of each target.  Each target is matched against the
TARGET-PATTERN to extract a part of the target name, called the "stem".
This stem is substituted into each of the PREREQ-PATTERNS to make the
prerequisite names (one from each PREREQ-PATTERN).

   Each pattern normally contains the character '%' just once.  When the
TARGET-PATTERN matches a target, the '%' can match any part of the
target name; this part is called the "stem".  The rest of the pattern
must match exactly.  For example, the target 'foo.o' matches the pattern
'%.o', with 'foo' as the stem.  The targets 'foo.c' and 'foo.out' do not
match that pattern.

   The prerequisite names for each target are made by substituting the
stem for the '%' in each prerequisite pattern.  For example, if one
prerequisite pattern is '%.c', then substitution of the stem 'foo' gives
the prerequisite name 'foo.c'.  It is legitimate to write a prerequisite
pattern that does not contain '%'; then this prerequisite is the same
for all targets.

   '%' characters in pattern rules can be quoted with preceding
backslashes ('\').  Backslashes that would otherwise quote '%'
characters can be quoted with more backslashes.  Backslashes that quote
'%' characters or other backslashes are removed from the pattern before
it is compared to file names or has a stem substituted into it.
Backslashes that are not in danger of quoting '%' characters go
unmolested.  For example, the pattern 'the\%weird\\%pattern\\' has
'the%weird\' preceding the operative '%' character, and 'pattern\\'
following it.  The final two backslashes are left alone because they
cannot affect any '%' character.

   Here is an example, which compiles each of 'foo.o' and 'bar.o' from
the corresponding '.c' file:

     objects = foo.o bar.o

     all: $(objects)

     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@

Here '$<' is the automatic variable that holds the name of the
prerequisite and '$@' is the automatic variable that holds the name of
the target; see *note Automatic Variables::.

   Each target specified must match the target pattern; a warning is
issued for each target that does not.  If you have a list of files, only
some of which will match the pattern, you can use the 'filter' function
to remove non-matching file names (*note Functions for String
Substitution and Analysis: Text Functions.):

     files = foo.elc bar.o lose.o

     $(filter %.o,$(files)): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $<

In this example the result of '$(filter %.o,$(files))' is 'bar.o
lose.o', and the first static pattern rule causes each of these object
files to be updated by compiling the corresponding C source file.  The
result of '$(filter %.elc,$(files))' is 'foo.elc', so that file is made
from 'foo.el'.

   Another example shows how to use '$*' in static pattern rules:

     bigoutput littleoutput : %output : text.g
             generate text.g -$* > $@

When the 'generate' command is run, '$*' will expand to the stem, either
'big' or 'little'.

4.12.2 Static Pattern Rules versus Implicit Rules
-------------------------------------------------

A static pattern rule has much in common with an implicit rule defined
as a pattern rule (*note Defining and Redefining Pattern Rules: Pattern
Rules.).  Both have a pattern for the target and patterns for
constructing the names of prerequisites.  The difference is in how
'make' decides _when_ the rule applies.

   An implicit rule _can_ apply to any target that matches its pattern,
but it _does_ apply only when the target has no recipe otherwise
specified, and only when the prerequisites can be found.  If more than
one implicit rule appears applicable, only one applies; the choice
depends on the order of rules.

   By contrast, a static pattern rule applies to the precise list of
targets that you specify in the rule.  It cannot apply to any other
target and it invariably does apply to each of the targets specified.
If two conflicting rules apply, and both have recipes, that's an error.

   The static pattern rule can be better than an implicit rule for these
reasons:

   * You may wish to override the usual implicit rule for a few files
     whose names cannot be categorized syntactically but can be given in
     an explicit list.

   * If you cannot be sure of the precise contents of the directories
     you are using, you may not be sure which other irrelevant files
     might lead 'make' to use the wrong implicit rule.  The choice might
     depend on the order in which the implicit rule search is done.
     With static pattern rules, there is no uncertainty: each rule
     applies to precisely the targets specified.

4.13 Double-Colon Rules
=======================

"Double-colon" rules are explicit rules written with '::' instead of ':'
after the target names.  They are handled differently from ordinary
rules when the same target appears in more than one rule.  Pattern rules
with double-colons have an entirely different meaning (*note
Match-Anything Rules::).

   When a target appears in multiple rules, all the rules must be the
same type: all ordinary, or all double-colon.  If they are double-colon,
each of them is independent of the others.  Each double-colon rule's
recipe is executed if the target is older than any prerequisites of that
rule.  If there are no prerequisites for that rule, its recipe is always
executed (even if the target already exists).  This can result in
executing none, any, or all of the double-colon rules.

   Double-colon rules with the same target are in fact completely
separate from one another.  Each double-colon rule is processed
individually, just as rules with different targets are processed.

   The double-colon rules for a target are executed in the order they
appear in the makefile.  However, the cases where double-colon rules
really make sense are those where the order of executing the recipes
would not matter.

   Double-colon rules are somewhat obscure and not often very useful;
they provide a mechanism for cases in which the method used to update a
target differs depending on which prerequisite files caused the update,
and such cases are rare.

   Each double-colon rule should specify a recipe; if it does not, an
implicit rule will be used if one applies.  *Note Using Implicit Rules:
Implicit Rules.

4.14 Generating Prerequisites Automatically
===========================================

In the makefile for a program, many of the rules you need to write often
say only that some object file depends on some header file.  For
example, if 'main.c' uses 'defs.h' via an '#include', you would write:

     main.o: defs.h

You need this rule so that 'make' knows that it must remake 'main.o'
whenever 'defs.h' changes.  You can see that for a large program you
would have to write dozens of such rules in your makefile.  And, you
must always be very careful to update the makefile every time you add or
remove an '#include'.

   To avoid this hassle, most modern C compilers can write these rules
for you, by looking at the '#include' lines in the source files.
Usually this is done with the '-M' option to the compiler.  For example,
the command:

     cc -M main.c

generates the output:

     main.o : main.c defs.h

Thus you no longer have to write all those rules yourself.  The compiler
will do it for you.

   Note that such a rule constitutes mentioning 'main.o' in a makefile,
so it can never be considered an intermediate file by implicit rule
search.  This means that 'make' won't ever remove the file after using
it; *note Chains of Implicit Rules: Chained Rules.
